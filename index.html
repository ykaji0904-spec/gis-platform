<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GIS Platform - ホース延長シミュレーター</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Noto Sans JP', sans-serif; overflow: hidden; background: #0a0a0a; }
        #cesiumContainer { width: 100vw; height: 100vh; }

        .top-bar {
            position: fixed; top: 0; left: 0; right: 0; height: 48px;
            background: rgba(10, 10, 10, 0.9); backdrop-filter: blur(16px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 10px; z-index: 1000;
        }
        .logo { display: flex; align-items: center; cursor: pointer; }
        .logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, #00d4ff, #0099ff); border-radius: 8px; display: flex; align-items: center; justify-content: center; }
        .logo-icon .material-icons { color: white; font-size: 18px; }

        .map-switcher { display: flex; background: rgba(255, 255, 255, 0.08); border-radius: 20px; padding: 3px; }
        .map-btn { padding: 5px 12px; border: none; background: transparent; color: rgba(255,255,255,0.6); font-size: 10px; cursor: pointer; border-radius: 16px; display: flex; align-items: center; gap: 4px; }
        .map-btn.active { background: rgba(0, 212, 255, 0.2); color: #00d4ff; }
        .map-btn .material-icons { font-size: 14px; }

        .search-box { display: flex; align-items: center; max-width: 180px; }
        .search-input { width: 100%; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 16px; padding: 5px 12px; color: white; font-size: 10px; outline: none; }
        .search-input::placeholder { color: rgba(255,255,255,0.4); }

        .top-right { display: flex; align-items: center; gap: 8px; }
        .avatar { width: 28px; height: 28px; background: linear-gradient(135deg, #ff6b6b, #ffa06b); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 11px; }

        .quick-toggles { position: fixed; top: 56px; right: 8px; display: flex; gap: 4px; z-index: 900; }
        .quick-toggle { display: flex; align-items: center; gap: 3px; background: rgba(10,10,10,0.85); border: 1px solid rgba(255, 255, 255, 0.12); padding: 5px 8px; border-radius: 14px; cursor: pointer; color: rgba(255, 255, 255, 0.5); font-size: 10px; }
        .quick-toggle.active { background: rgba(0, 212, 255, 0.15); border-color: #00d4ff; color: #00d4ff; }
        .quick-toggle .material-icons { font-size: 13px; }

        .tool-menu { position: fixed; top: 56px; left: 8px; width: 260px; background: rgba(10, 10, 10, 0.95); backdrop-filter: blur(20px); border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.1); z-index: 950; display: none; max-height: calc(100vh - 120px); overflow-y: auto; }
        .tool-menu.show { display: block; }
        .tool-menu-header { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.08); display: flex; align-items: center; justify-content: space-between; }
        .tool-menu-title { color: white; font-size: 12px; font-weight: 600; }
        .tool-menu-close { background: none; border: none; color: rgba(255,255,255,0.5); cursor: pointer; }
        .tool-section { padding: 8px 10px; border-bottom: 1px solid rgba(255,255,255,0.04); }
        .tool-section-title { color: rgba(255,255,255,0.35); font-size: 9px; text-transform: uppercase; margin-bottom: 6px; }
        .tool-item { display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 6px; margin-bottom: 4px; cursor: pointer; background: rgba(255,255,255,0.02); }
        .tool-item:hover { background: rgba(255,255,255,0.05); }
        .tool-item.active { background: rgba(0, 212, 255, 0.1); border: 1px solid rgba(0, 212, 255, 0.2); }
        .tool-item-icon { width: 32px; height: 32px; border-radius: 6px; display: flex; align-items: center; justify-content: center; }
        .tool-item-icon.fire { background: rgba(244, 67, 54, 0.15); color: #f44336; }
        .tool-item-icon.water { background: rgba(33, 150, 243, 0.15); color: #2196f3; }
        .tool-item-icon.hose { background: rgba(255, 152, 0, 0.15); color: #ff9800; }
        .tool-item-icon.measure { background: rgba(0, 212, 255, 0.15); color: #00d4ff; }
        .tool-item-icon.layer { background: rgba(139, 195, 74, 0.15); color: #8bc34a; }
        .tool-item-icon .material-icons { font-size: 16px; }
        .tool-item-content { flex: 1; }
        .tool-item-name { color: white; font-size: 11px; font-weight: 500; }
        .tool-item-desc { color: rgba(255,255,255,0.4); font-size: 9px; margin-top: 2px; }

        .layer-panel { position: fixed; top: 56px; left: 8px; width: 240px; background: rgba(10, 10, 10, 0.95); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); z-index: 900; display: none; max-height: calc(100vh - 120px); overflow-y: auto; }
        .layer-panel.show { display: block; }
        .panel-section { padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.04); }
        .section-title { color: rgba(255,255,255,0.35); font-size: 8px; text-transform: uppercase; margin-bottom: 6px; }
        .layer-item { display: flex; align-items: center; justify-content: space-between; padding: 6px; border-radius: 4px; margin-bottom: 2px; cursor: pointer; }
        .layer-item:hover { background: rgba(255,255,255,0.04); }
        .layer-info { display: flex; align-items: center; gap: 6px; }
        .layer-icon { width: 20px; height: 20px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 10px; }
        .layer-icon.hazard { background: rgba(255, 87, 34, 0.15); color: #ff5722; }
        .layer-name { color: white; font-size: 10px; }
        .layer-toggle { width: 28px; height: 16px; border-radius: 8px; background: rgba(255,255,255,0.1); position: relative; cursor: pointer; }
        .layer-toggle.on { background: #00d4ff; }
        .layer-toggle::after { content: ''; position: absolute; width: 12px; height: 12px; background: white; border-radius: 50%; top: 2px; left: 2px; transition: all 0.2s; }
        .layer-toggle.on::after { left: 14px; }

        .mode-indicator { position: fixed; top: 56px; left: 50%; transform: translateX(-50%); background: rgba(244, 67, 54, 0.9); padding: 6px 12px; border-radius: 16px; display: none; align-items: center; gap: 6px; z-index: 1000; }
        .mode-indicator.show { display: flex; }
        .mode-indicator.water-mode { background: rgba(33, 150, 243, 0.9); }
        .mode-indicator.hose-mode { background: rgba(255, 152, 0, 0.9); }
        .mode-indicator.measure-mode { background: rgba(0, 212, 255, 0.9); }
        .mode-indicator .material-icons { color: white; font-size: 14px; }
        .mode-indicator span { color: white; font-size: 11px; font-weight: 500; }

        .bottom-panel { position: fixed; bottom: 56px; left: 8px; right: 8px; background: rgba(10, 10, 10, 0.95); padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.1); z-index: 900; display: none; }
        .bottom-panel.active { display: block; }
        .bottom-panel.fire { border-color: rgba(244, 67, 54, 0.25); }
        .bottom-panel.water { border-color: rgba(33, 150, 243, 0.25); }
        .bottom-panel.hose { border-color: rgba(255, 152, 0, 0.25); }
        .bottom-panel.measure { border-color: rgba(0, 212, 255, 0.25); }
        .panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .panel-title { font-size: 11px; font-weight: 600; display: flex; align-items: center; gap: 4px; }
        .panel-title.fire { color: #f44336; }
        .panel-title.water { color: #2196f3; }
        .panel-title.hose { color: #ff9800; }
        .panel-title.measure { color: #00d4ff; }
        .panel-title .material-icons { font-size: 14px; }
        .panel-close { background: none; border: none; color: rgba(255,255,255,0.4); cursor: pointer; }
        .panel-stats { display: flex; gap: 6px; flex-wrap: wrap; }
        .panel-stat { background: rgba(255,255,255,0.03); padding: 6px 8px; border-radius: 6px; min-width: 70px; }
        .panel-stat.wide { flex: 1; min-width: 100px; }
        .panel-stat-label { color: rgba(255,255,255,0.4); font-size: 8px; margin-bottom: 2px; }
        .panel-stat-value { color: white; font-size: 12px; font-weight: 600; font-family: monospace; }
        .panel-stat-value.highlight { color: #ff9800; }
        .panel-stat-value.fire-highlight { color: #f44336; }
        .panel-stat-value.water-highlight { color: #2196f3; }
        .panel-stat-value.measure-highlight { color: #00d4ff; }
        .panel-stat-value.warning { color: #f44336; }
        .panel-stat-value.ok { color: #4ade80; }
        .panel-hint { color: rgba(255,255,255,0.35); font-size: 9px; text-align: center; margin: 8px 0; }
        .panel-actions { display: flex; gap: 6px; margin-top: 8px; }
        .panel-btn { flex: 1; padding: 8px; border: none; border-radius: 6px; font-size: 10px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 4px; font-weight: 500; }
        .panel-btn .material-icons { font-size: 14px; }
        .panel-btn.primary { background: #ff9800; color: #000; }
        .panel-btn.primary-cyan { background: #00d4ff; color: #000; }
        .panel-btn.secondary { background: rgba(255,255,255,0.08); color: white; }
        .panel-btn.danger { background: #f44336; color: white; }

        .water-list { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 6px; }
        .water-chip { display: flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 12px; background: rgba(255,255,255,0.05); cursor: pointer; font-size: 9px; border: 1px solid rgba(255,255,255,0.1); }

        /* Simulation Parameters Panel */
        .sim-params { margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.08); }
        .sim-params-title { color: rgba(255,255,255,0.5); font-size: 8px; margin-bottom: 6px; }
        .sim-param-row { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
        .sim-param-label { color: rgba(255,255,255,0.6); font-size: 9px; min-width: 80px; }
        .sim-param-input { width: 60px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 4px; padding: 3px 6px; color: white; font-size: 10px; text-align: right; }
        .sim-param-unit { color: rgba(255,255,255,0.4); font-size: 9px; }

        /* Warning message */
        .sim-warning { background: rgba(244, 67, 54, 0.15); border: 1px solid rgba(244, 67, 54, 0.3); border-radius: 6px; padding: 6px 10px; margin-top: 8px; display: none; }
        .sim-warning.show { display: block; }
        .sim-warning-text { color: #f44336; font-size: 10px; display: flex; align-items: center; gap: 4px; }
        .sim-warning-text .material-icons { font-size: 14px; }

        /* Segment details */
        .segment-list { max-height: 120px; overflow-y: auto; margin-top: 8px; }
        .segment-item { display: flex; align-items: center; gap: 6px; padding: 4px 6px; background: rgba(255,255,255,0.02); border-radius: 4px; margin-bottom: 2px; font-size: 9px; }
        .segment-color { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
        .segment-color.green { background: #4ade80; }
        .segment-color.yellow { background: #fbbf24; }
        .segment-color.red { background: #ef4444; }
        .segment-info { flex: 1; color: rgba(255,255,255,0.7); }
        .segment-loss { color: white; font-weight: 500; min-width: 60px; text-align: right; }

        /* Legend */
        .sim-legend { display: flex; gap: 12px; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.08); }
        .legend-item { display: flex; align-items: center; gap: 4px; font-size: 8px; color: rgba(255,255,255,0.5); }
        .legend-dot { width: 8px; height: 8px; border-radius: 50%; }
        .legend-dot.green { background: #4ade80; }
        .legend-dot.yellow { background: #fbbf24; }
        .legend-dot.red { background: #ef4444; }
        .legend-dot.start { background: #ef4444; border: 2px solid white; }
        .legend-dot.end { background: #3b82f6; border: 2px solid white; }
        .legend-dot.cand { background: #ef4444; }
        .legend-dot.conf { background: #ff9800; }

        .bottom-bar { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(10, 10, 10, 0.95); border-top: 1px solid rgba(255, 255, 255, 0.08); padding: 6px 10px; z-index: 1000; display: flex; align-items: center; justify-content: space-between; }
        .my-location { display: flex; align-items: center; gap: 6px; background: rgba(255, 255, 255, 0.05); padding: 6px 10px; border-radius: 6px; cursor: pointer; }
        .my-location .material-icons { font-size: 16px; color: #4ade80; }
        .my-location-coords { color: white; font-size: 10px; font-family: monospace; }
        .view-toggle { display: flex; background: rgba(255, 255, 255, 0.05); border-radius: 6px; }
        .view-btn { padding: 6px 12px; border: none; background: transparent; color: rgba(255,255,255,0.5); cursor: pointer; font-size: 10px; display: flex; align-items: center; gap: 3px; }
        .view-btn.active { background: rgba(0, 212, 255, 0.15); color: #00d4ff; border-radius: 6px; }
        .view-btn .material-icons { font-size: 12px; }

        .credit-bar { position: fixed; bottom: 52px; right: 8px; background: rgba(0,0,0,0.6); padding: 3px 8px; border-radius: 4px; font-size: 8px; color: rgba(255,255,255,0.7); z-index: 800; }
        .credit-bar a { color: #4fc3f7; text-decoration: none; }
        .coord-display { position: fixed; bottom: 52px; left: 8px; background: rgba(0,0,0,0.6); padding: 4px 8px; border-radius: 4px; font-size: 9px; color: rgba(255,255,255,0.8); font-family: monospace; z-index: 800; }

        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(10,10,10,0.95); padding: 16px 24px; border-radius: 10px; color: white; font-size: 11px; display: none; z-index: 2000; text-align: center; }
        .loading.show { display: block; }
        .toast { position: fixed; top: 100px; left: 50%; transform: translateX(-50%); background: rgba(50,50,50,0.95); padding: 10px 16px; border-radius: 8px; color: white; font-size: 11px; z-index: 2100; display: none; }
        .toast.show { display: block; animation: fadeInOut 2.5s ease; }
        @keyframes fadeInOut { 0%,100% { opacity: 0; } 10%,90% { opacity: 1; } }

        .search-results { position: fixed; top: 52px; right: 60px; width: 250px; max-height: 200px; overflow-y: auto; background: rgba(20,20,20,0.98); border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); z-index: 1100; display: none; }
        .search-results.show { display: block; }
        .search-result-item { padding: 10px 12px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .search-result-item:hover { background: rgba(255,255,255,0.05); }
        .search-result-name { color: white; font-size: 11px; }
        .search-result-address { color: rgba(255,255,255,0.5); font-size: 9px; margin-top: 2px; }

        .cesium-viewer-toolbar, .cesium-viewer-animationContainer, .cesium-viewer-timelineContainer, .cesium-viewer-fullscreenContainer, .cesium-viewer-bottom { display: none !important; }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <div class="loading" id="loading">読み込み中...</div>
    <div class="toast" id="toast"></div>
    <div class="credit-bar" id="creditBar">© Cesium ion</div>
    <div class="coord-display" id="coordDisplay">--</div>
    <div class="search-results" id="searchResults"></div>

    <div class="top-bar">
        <div class="logo" onclick="toggleToolMenu()"><div class="logo-icon"><span class="material-icons">menu</span></div></div>
        <div class="map-switcher">
            <button class="map-btn active" id="mapBtnSatellite" onclick="setBasemap('satellite')"><span class="material-icons">satellite</span><span>衛星</span></button>
            <button class="map-btn" id="mapBtnStd" onclick="setBasemap('std')"><span class="material-icons">map</span><span>地図</span></button>
            <button class="map-btn" id="mapBtnPale" onclick="setBasemap('pale')"><span class="material-icons">layers</span><span>淡色</span></button>
        </div>
        <div class="top-right">
            <div class="search-box"><input type="text" class="search-input" id="searchInput" placeholder="検索..." onkeydown="if(event.key==='Enter')doSearch()"></div>
            <div class="avatar">K</div>
        </div>
    </div>

    <div class="quick-toggles">
        <div class="quick-toggle active" onclick="toggleQuickLayer(this, 'terrain')"><span class="material-icons">terrain</span></div>
        <div class="quick-toggle active" onclick="toggleQuickLayer(this, 'buildings')"><span class="material-icons">location_city</span></div>
        <div class="quick-toggle" onclick="toggleQuickLayer(this, 'trails')"><span class="material-icons">hiking</span></div>
    </div>

    <div class="mode-indicator" id="modeIndicator">
        <span class="material-icons" id="modeIcon">local_fire_department</span>
        <span id="modeText">火点追加</span>
    </div>

    <div class="tool-menu" id="toolMenu">
        <div class="tool-menu-header"><span class="tool-menu-title">ツール</span><button class="tool-menu-close" onclick="toggleToolMenu()"><span class="material-icons">close</span></button></div>
        <div class="tool-section">
            <div class="tool-section-title">オペレーション</div>
            <div class="tool-item" id="toolFire" onclick="setTool('fire')"><div class="tool-item-icon fire"><span class="material-icons">local_fire_department</span></div><div class="tool-item-content"><div class="tool-item-name">火点追加</div><div class="tool-item-desc">タップで追加</div></div></div>
            <div class="tool-item" id="toolWater" onclick="setTool('water')"><div class="tool-item-icon water"><span class="material-icons">water_drop</span></div><div class="tool-item-content"><div class="tool-item-name">水利追加</div><div class="tool-item-desc">消火栓・防火水槽</div></div></div>
        </div>
        <div class="tool-section">
            <div class="tool-section-title">計測・シミュレーション</div>
            <div class="tool-item" id="toolHose" onclick="setTool('hose')"><div class="tool-item-icon hose"><span class="material-icons">route</span></div><div class="tool-item-content"><div class="tool-item-name">ホース延長(林野)</div><div class="tool-item-desc">中継可搬シミュレーション</div></div></div>
            <div class="tool-item" id="toolMeasure" onclick="setTool('measure')"><div class="tool-item-icon measure"><span class="material-icons">straighten</span></div><div class="tool-item-content"><div class="tool-item-name">2点計測</div><div class="tool-item-desc">距離と高低差</div></div></div>
        </div>
        <div class="tool-section">
            <div class="tool-section-title">表示</div>
            <div class="tool-item" onclick="showLayerPanel()"><div class="tool-item-icon layer"><span class="material-icons">layers</span></div><div class="tool-item-content"><div class="tool-item-name">レイヤー</div><div class="tool-item-desc">ハザードマップ等</div></div></div>
            <div class="tool-item" onclick="shareView()"><div class="tool-item-icon layer"><span class="material-icons">share</span></div><div class="tool-item-content"><div class="tool-item-name">共有</div><div class="tool-item-desc">URLをコピー</div></div></div>
        </div>
    </div>

    <div class="layer-panel" id="layerPanel">
        <div class="panel-section">
            <div class="section-title">ハザードマップ</div>
            <div class="layer-item" onclick="toggleLayerItem(this, 'flood')"><div class="layer-info"><div class="layer-icon hazard"><span class="material-icons">water</span></div><span class="layer-name">洪水浸水想定</span></div><div class="layer-toggle" id="toggle-flood"></div></div>
            <div class="layer-item" onclick="toggleLayerItem(this, 'tsunami')"><div class="layer-info"><div class="layer-icon hazard"><span class="material-icons">waves</span></div><span class="layer-name">津波浸水想定</span></div><div class="layer-toggle" id="toggle-tsunami"></div></div>
            <div class="layer-item" onclick="toggleLayerItem(this, 'landslide')"><div class="layer-info"><div class="layer-icon hazard"><span class="material-icons">landslide</span></div><span class="layer-name">土砂災害警戒</span></div><div class="layer-toggle" id="toggle-landslide"></div></div>
        </div>
    </div>

    <!-- Fire Panel -->
    <div class="bottom-panel fire" id="firePanel">
        <div class="panel-header"><span class="panel-title fire"><span class="material-icons">local_fire_department</span>火点</span><button class="panel-close" onclick="closePanel('fire')"><span class="material-icons">close</span></button></div>
        <div class="panel-stats">
            <div class="panel-stat"><div class="panel-stat-label">緯度</div><div class="panel-stat-value" id="fireLat">-</div></div>
            <div class="panel-stat"><div class="panel-stat-label">経度</div><div class="panel-stat-value" id="fireLon">-</div></div>
            <div class="panel-stat"><div class="panel-stat-label">標高</div><div class="panel-stat-value fire-highlight" id="fireElev">-</div></div>
        </div>
        <div class="section-title" style="margin-top:8px;">周辺水利</div>
        <div class="water-list" id="nearbyWaterList"></div>
        <div class="panel-actions">
            <button class="panel-btn secondary" onclick="flyToSelectedFire()"><span class="material-icons">flight</span>移動</button>
            <button class="panel-btn danger" onclick="deleteSelectedFire()"><span class="material-icons">delete</span>削除</button>
        </div>
    </div>

    <!-- Water Panel -->
    <div class="bottom-panel water" id="waterPanel">
        <div class="panel-header"><span class="panel-title water"><span class="material-icons">water_drop</span>水利</span><button class="panel-close" onclick="closePanel('water')"><span class="material-icons">close</span></button></div>
        <div class="panel-stats">
            <div class="panel-stat"><div class="panel-stat-label">種別</div><div class="panel-stat-value water-highlight" id="waterType">-</div></div>
            <div class="panel-stat"><div class="panel-stat-label">緯度</div><div class="panel-stat-value" id="waterLat">-</div></div>
            <div class="panel-stat"><div class="panel-stat-label">経度</div><div class="panel-stat-value" id="waterLon">-</div></div>
        </div>
        <div class="panel-actions">
            <button class="panel-btn secondary" onclick="flyToSelectedWater()"><span class="material-icons">flight</span>移動</button>
            <button class="panel-btn danger" onclick="deleteSelectedWater()"><span class="material-icons">delete</span>削除</button>
        </div>
    </div>

    <!-- Hose Info Panel (シミュレーション結果) -->
    <div class="bottom-panel hose-info" id="hoseInfoPanel">
        <div class="panel-header"><span class="panel-title hose"><span class="material-icons">route</span>ホース延長シミュレーション</span><button class="panel-close" onclick="closePanel('hoseInfo')"><span class="material-icons">close</span></button></div>
        <div class="panel-stats">
            <div class="panel-stat"><div class="panel-stat-label">総延長</div><div class="panel-stat-value highlight" id="hoseInfoDist">-</div></div>
            <div class="panel-stat"><div class="panel-stat-label">ホース本数</div><div class="panel-stat-value" id="hoseInfoCount">-</div></div>
            <div class="panel-stat"><div class="panel-stat-label">総損失</div><div class="panel-stat-value" id="hoseInfoLoss">-</div></div>
            <div class="panel-stat"><div class="panel-stat-label">筒先圧</div><div class="panel-stat-value" id="hoseInfoEndP">-</div></div>
            <div class="panel-stat"><div class="panel-stat-label">可搬台数</div><div class="panel-stat-value" id="hoseInfoRelay">-</div></div>
            <div class="panel-stat"><div class="panel-stat-label">累計上り</div><div class="panel-stat-value" id="hoseInfoElev">-</div></div>
        </div>
        <div class="sim-warning" id="simWarning">
            <div class="sim-warning-text"><span class="material-icons">warning</span><span id="simWarningText">筒先圧が0.3MPa未満です</span></div>
        </div>
        <div class="section-title" style="margin-top:8px;">ポンプ間の損失と残圧</div>
        <div class="segment-list" id="segmentList"></div>
        <div class="sim-legend">
            <div class="legend-item"><div class="legend-dot conf"></div>Pn(可搬)</div>
            <div class="legend-item"><div class="legend-dot end"></div>筒先</div>
            <div class="legend-item"><div class="legend-dot green"></div>≥0.4MPa</div>
            <div class="legend-item"><div class="legend-dot yellow"></div>≥0.2MPa</div>
            <div class="legend-item"><div class="legend-dot red"></div>&lt;0.2MPa</div>
        </div>
        <div class="sim-params">
            <div class="sim-params-title">計算条件（林野65mm・固定）</div>
            <div class="sim-param-row">
                <span class="sim-param-label">吐出圧</span>
                <span class="sim-param-input" style="background:transparent;border:none;color:#4ade80;">0.6</span>
                <span class="sim-param-unit">MPa（固定）</span>
            </div>
            <div class="sim-param-row">
                <span class="sim-param-label">中継入口最低</span>
                <span class="sim-param-input" style="background:transparent;border:none;color:#fbbf24;">0.2</span>
                <span class="sim-param-unit">MPa（固定）</span>
            </div>
            <div class="sim-param-row">
                <span class="sim-param-label">筒先要求</span>
                <span class="sim-param-input" style="background:transparent;border:none;color:#ef4444;">0.3</span>
                <span class="sim-param-unit">MPa（固定）</span>
            </div>
            <div class="sim-params-title" style="margin-top:8px;">調整可能</div>
            <div class="sim-param-row">
                <span class="sim-param-label">摩擦損失係数</span>
                <input type="number" class="sim-param-input" id="paramK" value="0.04" step="0.01" onchange="onParamChange()">
                <span class="sim-param-unit">MPa/100m</span>
            </div>
            <div class="sim-param-row">
                <span class="sim-param-label">付加損失</span>
                <input type="number" class="sim-param-input" id="paramExtra" value="0.02" step="0.01" onchange="onParamChange()">
                <span class="sim-param-unit">MPa/本</span>
            </div>
        </div>
        <div class="panel-hint">赤丸 = 中継可搬の設置候補位置（残圧0.2MPa到達点）</div>
        <div class="panel-actions"><button class="panel-btn danger" onclick="deleteSelectedHose()"><span class="material-icons">delete</span>削除</button></div>
    </div>

    <!-- Hose Drawing Panel -->
    <div class="bottom-panel hose" id="hosePanel">
        <div class="panel-header"><span class="panel-title hose"><span class="material-icons">route</span>ホース延長(林野)</span><button class="panel-close" onclick="closeHosePanel()"><span class="material-icons">close</span></button></div>
        <div class="panel-stats">
            <div class="panel-stat"><div class="panel-stat-label">総延長</div><div class="panel-stat-value highlight" id="hoseTotalDist">0m</div></div>
            <div class="panel-stat"><div class="panel-stat-label">本数(20m)</div><div class="panel-stat-value" id="hoseTotalCount">0本</div></div>
            <div class="panel-stat"><div class="panel-stat-label">高低差</div><div class="panel-stat-value" id="hoseElevInfo">-</div></div>
        </div>
        <div class="panel-hint" id="hoseHint">連続タップでポイント追加</div>
        <div class="panel-actions">
            <button class="panel-btn secondary" onclick="undoHosePoint()"><span class="material-icons">undo</span>戻す</button>
            <button class="panel-btn danger" onclick="resetHoseLine()"><span class="material-icons">delete</span></button>
            <button class="panel-btn primary" onclick="confirmHoseLine()"><span class="material-icons">check</span>確定</button>
        </div>
    </div>

    <!-- Measure Panel -->
    <div class="bottom-panel measure" id="measurePanel">
        <div class="panel-header"><span class="panel-title measure">2点計測</span><button class="panel-close" onclick="closeMeasurePanel()"><span class="material-icons">close</span></button></div>
        <div class="panel-stats">
            <div class="panel-stat"><div class="panel-stat-label">距離</div><div class="panel-stat-value measure-highlight" id="measureDistance">-</div></div>
            <div class="panel-stat"><div class="panel-stat-label">高低差</div><div class="panel-stat-value" id="measureElevation">-</div></div>
        </div>
        <div class="panel-hint" id="measureHint">2点タップで計測</div>
        <div class="panel-actions">
            <button class="panel-btn secondary" onclick="resetMeasure()">リセット</button>
            <button class="panel-btn primary-cyan" onclick="closeMeasurePanel()">完了</button>
        </div>
    </div>

    <!-- Bottom Bar -->
    <div class="bottom-bar">
        <div style="display:flex;align-items:center;">
            <div class="my-location" onclick="flyToMyLocation()">
                <span class="material-icons">my_location</span>
                <span class="my-location-coords" id="myCoords">取得中...</span>
            </div>
        </div>
        <div class="view-toggle">
            <button class="view-btn" onclick="setViewMode('2d')"><span class="material-icons">map</span>2D</button>
            <button class="view-btn active" onclick="setViewMode('3d')"><span class="material-icons">view_in_ar</span>3D</button>
        </div>
    </div>

    <script>
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwM2NhOTIxMi03NzRmLTQzMDgtYTMzZS1kOWEyMjBmNjhhMmEiLCJpZCI6Mzg1NDQ0LCJpYXQiOjE3Njk4Mzg4NTl9.ElD_8Qq0Mp1QuoaQvnODwTCVtEfaQtuDrsS9tnwlryA';

        const viewer = new Cesium.Viewer('cesiumContainer', {
            terrain: Cesium.Terrain.fromWorldTerrain(),
            timeline: false, animation: false, baseLayerPicker: false,
            geocoder: false, homeButton: false, sceneModePicker: false,
            navigationHelpButton: false, fullscreenButton: false,
            infoBox: false, selectionIndicator: false
        });
        viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(132.4553, 34.3853, 5000), duration: 0 });

        // ========== STATE ==========
        const layers = { terrain: true, buildings: true, trails: false, flood: false, tsunami: false, landslide: false };
        let plateauTileset = null, trailEntities = [], fireAreaEntity = null;
        let loadedTrailTiles = new Set(), trailLoadActive = false;

        // ========== 林野用シミュレーションパラメータ（新仕様） ==========
        const hoseParams = {
            // 固定条件
            pumpOutputMPa: 0.6,           // 可搬吐出圧（固定）
            minInletPressureMPa: 0.2,     // 中継入口最低圧
            nozzleRequiredMPa: 0.3,       // 筒先要求圧
            // 損失予算
            relayBudgetMPa: 0.4,          // 中継区間の許容損失（0.6 - 0.2）
            tailBudgetMPa: 0.3,           // 末端区間の許容損失（0.6 - 0.3）
            // 損失係数
            kFrictionMPaPer100m: 0.04,    // 摩擦損失係数
            extraLossPerHoseMPa: 0.02,    // 付加損失（1本20mあたり）
            hoseLengthM: 20               // 1本の長さ
        };

        // シミュレーション状態（ライン毎）
        const hoseSimState = {
            relayCandidateEntitiesByLine: new Map(),
            relayConfirmedEntitiesByLine: new Map(),
            relayConfirmedIdxByLine: new Map(),
            startEndEntitiesByLine: new Map()
        };

        // ========== BASEMAP ==========
        let currentBasemap = 'satellite';
        function setBasemap(key) {
            document.querySelectorAll('.map-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('mapBtn' + key.charAt(0).toUpperCase() + key.slice(1)).classList.add('active');
            viewer.imageryLayers.removeAll();
            if (key === 'satellite') {
                Cesium.IonImageryProvider.fromAssetId(2).then(p => viewer.imageryLayers.addImageryProvider(p));
                document.getElementById('creditBar').innerHTML = '© Cesium ion';
            } else {
                const urls = { std: 'https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', pale: 'https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png' };
                viewer.imageryLayers.addImageryProvider(new Cesium.UrlTemplateImageryProvider({ url: urls[key], maximumLevel: 18 }));
                document.getElementById('creditBar').innerHTML = '出典：<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">地理院タイル</a>';
            }
            Object.keys(hazardLayers).forEach(k => {
                const layer = viewer.imageryLayers.addImageryProvider(new Cesium.UrlTemplateImageryProvider({ url: hazardUrls[k], maximumLevel: 17 }));
                layer.alpha = 0.6; layer.show = layers[k]; hazardLayers[k] = layer;
            });
            currentBasemap = key;
        }

        // Hazard
        const hazardUrls = { flood: 'https://disaportaldata.gsi.go.jp/raster/01_flood_l2_shinsuishin_data/{z}/{x}/{y}.png', tsunami: 'https://disaportaldata.gsi.go.jp/raster/04_tsunami_newlegend_data/{z}/{x}/{y}.png', landslide: 'https://disaportaldata.gsi.go.jp/raster/05_dosekiryukeikaikuiki/{z}/{x}/{y}.png' };
        let hazardLayers = {};
        Object.keys(hazardUrls).forEach(k => { const layer = viewer.imageryLayers.addImageryProvider(new Cesium.UrlTemplateImageryProvider({ url: hazardUrls[k], maximumLevel: 17 })); layer.alpha = 0.6; layer.show = false; hazardLayers[k] = layer; });

        // PLATEAU
        (async () => { try { plateauTileset = await Cesium.Cesium3DTileset.fromIonAssetId(2602291); viewer.scene.primitives.add(plateauTileset); } catch(e){} })();

        // Layer toggles
        function toggleToolMenu() { document.getElementById('toolMenu').classList.toggle('show'); document.getElementById('layerPanel').classList.remove('show'); }
        function showLayerPanel() { document.getElementById('layerPanel').classList.toggle('show'); document.getElementById('toolMenu').classList.remove('show'); }
        function toggleQuickLayer(el, layer) { el.classList.toggle('active'); layers[layer] = el.classList.contains('active'); applyLayer(layer); }
        function toggleLayerItem(el, layer) { const t = el.querySelector('.layer-toggle'); t.classList.toggle('on'); layers[layer] = t.classList.contains('on'); applyLayer(layer); }
        function applyLayer(layer) {
            if (layer === 'terrain') viewer.scene.terrainProvider = layers.terrain ? Cesium.Terrain.fromWorldTerrain() : new Cesium.EllipsoidTerrainProvider();
            if (layer === 'buildings' && plateauTileset) plateauTileset.show = layers.buildings;
            if (layer === 'trails') { trailEntities.forEach(e => e.show = layers.trails); if (layers.trails) loadTrails(); }
            if (hazardLayers[layer]) hazardLayers[layer].show = layers[layer];
        }

        // Trails
        viewer.camera.moveEnd.addEventListener(() => { if (layers.trails) loadTrails(); });
        async function loadTrails() {
            if (trailLoadActive) return;
            const c = viewer.camera.positionCartographic, lat = Cesium.Math.toDegrees(c.latitude), lon = Cesium.Math.toDegrees(c.longitude);
            const key = `${Math.floor(lat/0.05)}_${Math.floor(lon/0.05)}`;
            if (loadedTrailTiles.has(key)) return;
            trailLoadActive = true; showLoading(true);
            try {
                const query = `[out:json][timeout:30];(way["highway"~"path|footway|track"](around:5000,${lat},${lon}););out body;>;out skel qt;`;
                const res = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
                const data = await res.json(), nodes = {};
                data.elements.filter(e => e.type === 'node').forEach(n => nodes[n.id] = [n.lon, n.lat]);
                data.elements.filter(e => e.type === 'way').forEach(way => {
                    if (trailEntities.some(e => e.osmId === way.id)) return;
                    const pos = way.nodes.filter(nid => nodes[nid]).map(nid => Cesium.Cartesian3.fromDegrees(nodes[nid][0], nodes[nid][1]));
                    if (pos.length >= 2) { const e = viewer.entities.add({ polyline: { positions: pos, width: 3, material: Cesium.Color.LIGHTGREEN.withAlpha(0.8), clampToGround: true } }); e.show = layers.trails; e.osmId = way.id; trailEntities.push(e); }
                });
                loadedTrailTiles.add(key);
            } catch(e){}
            trailLoadActive = false; showLoading(false);
        }

        // ========== FIRE POINTS ==========
        let firePoints = [], firePointEntities = [], selectedFirePoint = null, firePointIdCounter = 0;
        function addFirePoint(lon, lat, height) {
            const id = `fire-${++firePointIdCounter}`;
            firePoints.push({ id, lon, lat, height });
            const e = viewer.entities.add({ id: id, position: Cesium.Cartesian3.fromDegrees(lon, lat, height), billboard: { image: createFireIcon(), width: 28, height: 28, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND } });
            firePointEntities.push(e);
            updateFireArea();
            return id;
        }
        function createFireIcon() { const c = document.createElement('canvas'); c.width = 28; c.height = 28; const ctx = c.getContext('2d'); ctx.beginPath(); ctx.arc(14, 14, 12, 0, Math.PI * 2); ctx.fillStyle = 'rgba(244,67,54,0.3)'; ctx.fill(); ctx.beginPath(); ctx.arc(14, 14, 8, 0, Math.PI * 2); ctx.fillStyle = '#f44336'; ctx.fill(); ctx.beginPath(); ctx.arc(14, 14, 4, 0, Math.PI * 2); ctx.fillStyle = '#ffeb3b'; ctx.fill(); return c.toDataURL(); }
        function selectFirePoint(id) {
            const f = firePoints.find(p => p.id === id);
            if (!f) return;
            selectedFirePoint = f;
            closeAllPanels();
            document.getElementById('fireLat').textContent = f.lat.toFixed(5) + '°';
            document.getElementById('fireLon').textContent = f.lon.toFixed(5) + '°';
            document.getElementById('fireElev').textContent = f.height.toFixed(1) + 'm';
            document.getElementById('firePanel').classList.add('active');
            updateNearbyWaterList(f.lon, f.lat);
        }
        function updateNearbyWaterList(lon, lat) {
            const list = document.getElementById('nearbyWaterList');
            if (!waterSources.length) { list.innerHTML = '<span style="color:rgba(255,255,255,0.3);font-size:8px;">水利なし</span>'; return; }
            const sorted = waterSources.map(w => ({ ...w, d: geodesicDistance(lon, lat, w.lon, w.lat) })).sort((a, b) => a.d - b.d).slice(0, 5);
            list.innerHTML = sorted.map(w => `<div class="water-chip" onclick="selectWater('${w.id}')">${w.type[0].toUpperCase()} ${formatDistance(w.d)}</div>`).join('');
        }
        function updateFireArea() {
            if (fireAreaEntity) { viewer.entities.remove(fireAreaEntity); fireAreaEntity = null; }
            if (firePoints.length < 3) return;
            const hull = convexHull(firePoints.map(f => [f.lon, f.lat]));
            if (hull.length < 3) return;
            fireAreaEntity = viewer.entities.add({ polygon: { hierarchy: hull.map(c => Cesium.Cartesian3.fromDegrees(c[0], c[1])), material: Cesium.Color.RED.withAlpha(0.15), outline: true, outlineColor: Cesium.Color.RED, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND } });
        }
        function convexHull(pts) { if (pts.length < 3) return pts; const s = [...pts].sort((a, b) => a[0] - b[0] || a[1] - b[1]); const cr = (o, a, b) => (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]); const l = []; for (const p of s) { while (l.length >= 2 && cr(l[l.length - 2], l[l.length - 1], p) <= 0) l.pop(); l.push(p); } const u = []; for (let i = s.length - 1; i >= 0; i--) { const p = s[i]; while (u.length >= 2 && cr(u[u.length - 2], u[u.length - 1], p) <= 0) u.pop(); u.push(p); } u.pop(); l.pop(); return l.concat(u); }
        function flyToSelectedFire() { if (selectedFirePoint) viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(selectedFirePoint.lon, selectedFirePoint.lat, 400), duration: 1 }); }
        function deleteSelectedFire() {
            if (!selectedFirePoint) { showToast('火点が選択されていません'); return; }
            const id = selectedFirePoint.id;
            firePoints = firePoints.filter(f => f.id !== id);
            const entity = firePointEntities.find(e => e.id === id);
            if (entity) { viewer.entities.remove(entity); firePointEntities = firePointEntities.filter(e => e.id !== id); }
            selectedFirePoint = null;
            closePanel('fire');
            updateFireArea();
            showToast('火点を削除しました');
        }

        // ========== WATER SOURCES ==========
        let waterSources = [], waterEntities = [], selectedWater = null, waterIdCounter = 0;
        function addWaterSource(type, name, lon, lat) {
            const id = `water-${++waterIdCounter}`;
            waterSources.push({ id, type, name, lon, lat });
            const e = viewer.entities.add({ id: id, position: Cesium.Cartesian3.fromDegrees(lon, lat, 0), billboard: { image: createWaterIcon(type), width: 20, height: 20, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND } });
            waterEntities.push(e);
            return id;
        }
        function createWaterIcon(type) { const c = document.createElement('canvas'); c.width = 20; c.height = 20; const ctx = c.getContext('2d'); ctx.beginPath(); ctx.arc(10, 10, 8, 0, Math.PI * 2); ctx.fillStyle = { hydrant: '#f44336', tank: '#2196f3', natural: '#00bcd4' }[type] || '#2196f3'; ctx.fill(); ctx.fillStyle = 'white'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(type[0].toUpperCase(), 10, 10); return c.toDataURL(); }
        function selectWater(id) {
            const w = waterSources.find(x => x.id === id);
            if (!w) return;
            selectedWater = w;
            closeAllPanels();
            document.getElementById('waterType').textContent = { hydrant: '消火栓', tank: '防火水槽', natural: '自然水利' }[w.type] || w.type;
            document.getElementById('waterLat').textContent = w.lat.toFixed(5) + '°';
            document.getElementById('waterLon').textContent = w.lon.toFixed(5) + '°';
            document.getElementById('waterPanel').classList.add('active');
        }
        function flyToSelectedWater() { if (selectedWater) viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(selectedWater.lon, selectedWater.lat, 300), duration: 1 }); }
        function deleteSelectedWater() {
            if (!selectedWater) { showToast('水利が選択されていません'); return; }
            const id = selectedWater.id;
            waterSources = waterSources.filter(w => w.id !== id);
            const entity = waterEntities.find(e => e.id === id);
            if (entity) { viewer.entities.remove(entity); waterEntities = waterEntities.filter(e => e.id !== id); }
            selectedWater = null;
            closePanel('water');
            showToast('水利を削除しました');
        }
        addWaterSource('hydrant', '消火栓#1', 132.4548, 34.3858);
        addWaterSource('tank', '防火水槽', 132.4563, 34.3863);

        // ========== HOSE LINES (with Simulation) ==========
        let hoseLinePoints = [], hoseLineSegments = [], hoseLineMarkers = [], hoseLineEntities = [], hoseLineIdCounter = 0, selectedHoseLine = null;

        function updateHoseDisplay() {
            let totalDist = 0, cumElev = 0;
            for (let i = 1; i < hoseLinePoints.length; i++) {
                totalDist += geodesicDistance(hoseLinePoints[i-1].lon, hoseLinePoints[i-1].lat, hoseLinePoints[i].lon, hoseLinePoints[i].lat);
                cumElev += Math.abs(hoseLinePoints[i].height - hoseLinePoints[i-1].height);
            }
            document.getElementById('hoseTotalDist').textContent = formatDistance(totalDist);
            document.getElementById('hoseTotalCount').textContent = Math.ceil(totalDist / 20) + '本';
            document.getElementById('hoseElevInfo').textContent = hoseLinePoints.length > 1 ? cumElev.toFixed(1) + 'm' : '-';
            if (hoseLinePoints.length) document.getElementById('hoseHint').textContent = `${hoseLinePoints.length}点`;
        }

        function addHosePoint(lon, lat, height, cartesian) {
            hoseLinePoints.push({ lon, lat, height, cartesian });
            const m = viewer.entities.add({ position: cartesian, point: { pixelSize: 8, color: Cesium.Color.ORANGE, outlineColor: Cesium.Color.WHITE, outlineWidth: 1, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND } });
            hoseLineMarkers.push(m);
            if (hoseLinePoints.length >= 2) {
                const seg = viewer.entities.add({ polyline: { positions: [hoseLinePoints[hoseLinePoints.length-2].cartesian, cartesian], width: 5, material: new Cesium.PolylineDashMaterialProperty({ color: Cesium.Color.ORANGE, dashLength: 12 }), clampToGround: true } });
                hoseLineSegments.push(seg);
            }
            updateHoseDisplay();
        }

        function undoHosePoint() { if (!hoseLinePoints.length) return; hoseLinePoints.pop(); if (hoseLineMarkers.length) viewer.entities.remove(hoseLineMarkers.pop()); if (hoseLineSegments.length) viewer.entities.remove(hoseLineSegments.pop()); updateHoseDisplay(); }
        function resetHoseLine() { hoseLinePoints = []; hoseLineMarkers.forEach(e => viewer.entities.remove(e)); hoseLineMarkers = []; hoseLineSegments.forEach(e => viewer.entities.remove(e)); hoseLineSegments = []; updateHoseDisplay(); document.getElementById('hoseHint').textContent = '連続タップでポイント追加'; }

        // ========== シミュレーション計算（新仕様） ==========
        // 区間損失計算
        // - 摩擦損失: k × (L / 100)
        // - 高低差損失: 0.01 × max(0, Δh) ※上りのみ（安全側）
        // - 付加損失: 0.02 × ceil(L / 20) ※ホース本数ベース
        function calcSectionLoss(L, dh, params) {
            const friction = params.kFrictionMPaPer100m * (L / 100.0);
            const head = 0.01 * Math.max(0, dh);  // 下りは0扱い（安全側）
            const nHose = Math.ceil(L / params.hoseLengthM);
            const extra = params.extraLossPerHoseMPa * nHose;
            return { friction, head, extra, nHose, total: friction + head + extra };
        }

        function simulateHoseExtension(points, params) {
            const sections = [];
            let cumulative = 0;
            let totalHoses = 0;
            for (let i = 1; i < points.length; i++) {
                const p1 = points[i-1], p2 = points[i];
                const L = geodesicDistance(p1.lon, p1.lat, p2.lon, p2.lat);
                const dh = (p2.height || 0) - (p1.height || 0);
                const loss = calcSectionLoss(L, dh, params);
                cumulative += loss.total;
                totalHoses += loss.nHose;
                sections.push({
                    i,
                    lengthM: L,
                    elevDiffM: dh,
                    nHose: loss.nHose,
                    frictionLossMPa: loss.friction,
                    headLossMPa: loss.head,
                    extraLossMPa: loss.extra,
                    sectionLossMPa: loss.total,
                    cumulativeLossMPa: cumulative
                });
            }
            return {
                sections,
                totalLengthM: sections.reduce((s, x) => s + x.lengthM, 0),
                totalHoses20m: totalHoses,
                totalLossMPa: cumulative
            };
        }

        // 中継可搬の設置位置計算（損失予算方式）
        // P1(index=0)から0.6MPaで送水開始
        // 累積損失が予算を超える「直前」に次の可搬を配置
        // 中継区間: 予算0.4MPa（残圧0.2確保）
        // 最終区間: 予算0.3MPa（筒先圧0.3確保）
        function computeRelayPositions(points, params) {
            const relays = []; // 中継可搬の位置（P2, P3...のindex）
            const relayBudget = params.pumpOutputMPa - params.minInletPressureMPa; // 0.4
            const nozzleBudget = params.pumpOutputMPa - params.nozzleRequiredMPa;  // 0.3
            
            if (points.length < 2) return relays;
            
            let pumpIdx = 0; // 現在の可搬位置
            let safetyCount = 0;
            const maxIter = points.length * 2;
            
            while (pumpIdx < points.length - 1 && safetyCount < maxIter) {
                safetyCount++;
                
                // pumpIdxから終点までの累積損失を計算し、どこに次の可搬を置くか決定
                let accLoss = 0;
                let bestRelayIdx = -1;
                let lastSafeLoss = 0;
                
                for (let i = pumpIdx + 1; i < points.length; i++) {
                    const p1 = points[i - 1], p2 = points[i];
                    const L = geodesicDistance(p1.lon, p1.lat, p2.lon, p2.lat);
                    const dh = (p2.height || 0) - (p1.height || 0);
                    const loss = calcSectionLoss(L, dh, params);
                    accLoss += loss.total;
                    
                    // この点が終点かどうか
                    const isEnd = (i === points.length - 1);
                    
                    if (isEnd) {
                        // 終点に到達：筒先圧0.3確保できるか？
                        if (accLoss <= nozzleBudget) {
                            // OK、これ以上中継不要
                            pumpIdx = points.length; // ループ終了
                        } else {
                            // 筒先圧確保できない → 最後に置ける位置に中継
                            if (bestRelayIdx > pumpIdx && bestRelayIdx < points.length - 1) {
                                relays.push(bestRelayIdx);
                                pumpIdx = bestRelayIdx;
                            } else {
                                // 置ける位置がない場合は終了
                                pumpIdx = points.length;
                            }
                        }
                    } else {
                        // 中継区間：残圧0.2確保できるか？
                        if (accLoss <= relayBudget) {
                            // まだ余裕あり、この点を候補として記録
                            bestRelayIdx = i;
                            lastSafeLoss = accLoss;
                        } else {
                            // 予算超過 → 1つ前の点（bestRelayIdx）に可搬を置く
                            if (bestRelayIdx > pumpIdx) {
                                relays.push(bestRelayIdx);
                                pumpIdx = bestRelayIdx;
                            } else {
                                // 1区間で超過、やむなくこの点に置く
                                relays.push(i);
                                pumpIdx = i;
                            }
                            break;
                        }
                    }
                }
            }
            
            return relays;
        }

        // 各区間の残圧を計算（中継位置を考慮）
        // relayIndices = 中継可搬の位置（P2, P3, ...の位置）
        // index 0 は常に根本P1
        function computeSectionsWithPressure(points, params, relayIndices) {
            const sections = [];
            let currentPressure = params.pumpOutputMPa; // P1から0.6で開始
            const relaySet = new Set(relayIndices);
            let totalHoses = 0;
            let cumulative = 0;
            
            for (let i = 1; i < points.length; i++) {
                const startIdx = i - 1; // この区間の始点index
                const p1 = points[startIdx], p2 = points[i];
                const L = geodesicDistance(p1.lon, p1.lat, p2.lon, p2.lat);
                const dh = (p2.height || 0) - (p1.height || 0);
                const loss = calcSectionLoss(L, dh, params);
                
                // この区間の始点が中継位置なら圧力リセット（根本index=0以外）
                const isRelayStart = relaySet.has(startIdx);
                if (isRelayStart) {
                    currentPressure = params.pumpOutputMPa; // 0.6にリセット
                }
                
                // この区間の損失を引く
                currentPressure -= loss.total;
                cumulative += loss.total;
                totalHoses += loss.nHose;
                
                sections.push({
                    sectionNum: i, // 区間番号（1から）
                    startIdx: startIdx,
                    endIdx: i,
                    lengthM: L,
                    elevDiffM: dh,
                    nHose: loss.nHose,
                    sectionLossMPa: loss.total,
                    cumulativeLossMPa: cumulative,
                    remainingPressure: currentPressure,
                    isRelayPoint: isRelayStart
                });
            }
            
            return {
                sections,
                totalLengthM: sections.reduce((s, x) => s + x.lengthM, 0),
                totalHoses20m: totalHoses,
                totalLossMPa: cumulative
            };
        }

        // マーカー描画
        function renderStartEndMarkers(lineId, points) {
            const prev = hoseSimState.startEndEntitiesByLine.get(lineId);
            if (prev) {
                if (prev.start) viewer.entities.remove(prev.start);
                if (prev.end) viewer.entities.remove(prev.end);
            }
            const pStart = points[0], pEnd = points[points.length - 1];
            // 開始点 = 根本可搬（1台目）
            const startEnt = viewer.entities.add({
                id: `relay-start-${lineId}`,
                position: Cesium.Cartesian3.fromDegrees(pStart.lon, pStart.lat, pStart.height || 0),
                point: { pixelSize: 14, color: Cesium.Color.fromCssColorString('#ff9800'), outlineColor: Cesium.Color.WHITE, outlineWidth: 2, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND },
                label: { text: 'P1', font: 'bold 11px sans-serif', fillColor: Cesium.Color.WHITE, outlineColor: Cesium.Color.BLACK, outlineWidth: 2, style: Cesium.LabelStyle.FILL_AND_OUTLINE, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, pixelOffset: new Cesium.Cartesian2(0, -10) }
            });
            // 終了点 = 筒先
            const endEnt = viewer.entities.add({
                id: `relay-end-${lineId}`,
                position: Cesium.Cartesian3.fromDegrees(pEnd.lon, pEnd.lat, pEnd.height || 0),
                point: { pixelSize: 12, color: Cesium.Color.fromCssColorString('#3b82f6'), outlineColor: Cesium.Color.WHITE, outlineWidth: 2, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND },
                label: { text: '筒先', font: 'bold 10px sans-serif', fillColor: Cesium.Color.WHITE, outlineColor: Cesium.Color.BLACK, outlineWidth: 2, style: Cesium.LabelStyle.FILL_AND_OUTLINE, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, pixelOffset: new Cesium.Cartesian2(0, -10) }
            });
            hoseSimState.startEndEntitiesByLine.set(lineId, { start: startEnt, end: endEnt });
        }

        // 中継可搬マーカー描画（relayIndices = pointsのindex配列）
        function renderRelayMarkers(lineId, points, relayIndices) {
            const prev = hoseSimState.relayCandidateEntitiesByLine.get(lineId) || [];
            prev.forEach(e => viewer.entities.remove(e));
            
            const ents = relayIndices.map((idx, k) => {
                const p = points[idx];
                const pumpNum = k + 2; // 根本が1なので、2台目から
                const e = viewer.entities.add({
                    id: `relay-${lineId}-${k}`,
                    position: Cesium.Cartesian3.fromDegrees(p.lon, p.lat, p.height || 0),
                    point: { pixelSize: 14, color: Cesium.Color.fromCssColorString('#ff9800'), outlineColor: Cesium.Color.WHITE, outlineWidth: 2, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND },
                    label: {
                        text: `P${pumpNum}`,
                        font: 'bold 11px sans-serif',
                        fillColor: Cesium.Color.WHITE,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                        pixelOffset: new Cesium.Cartesian2(0, -10)
                    }
                });
                return e;
            });
            hoseSimState.relayCandidateEntitiesByLine.set(lineId, ents);
        }

        function createPumpIcon(color = '#ff9800') {
            const c = document.createElement('canvas'); c.width = 32; c.height = 32;
            const g = c.getContext('2d');
            g.beginPath(); g.arc(16, 16, 12, 0, Math.PI * 2); g.fillStyle = color; g.fill();
            g.fillStyle = '#000'; g.font = 'bold 12px sans-serif'; g.textAlign = 'center'; g.textBaseline = 'middle';
            g.fillText('P', 16, 16);
            return c.toDataURL();
        }

        // パネル更新（中継位置考慮版）
        function updateHoseInfoPanel(data) {
            document.getElementById('hoseInfoDist').textContent = formatDistance(data.totalLengthM);
            document.getElementById('hoseInfoCount').textContent = data.totalHoses20m + '本';
            document.getElementById('hoseInfoLoss').textContent = data.totalLossMPa.toFixed(2) + ' MPa';
            
            const endPEl = document.getElementById('hoseInfoEndP');
            // 末端圧表示（中継込みの計算結果）
            endPEl.textContent = data.endPressureMPa.toFixed(2) + ' MPa';
            if (data.endPressureMPa >= hoseParams.nozzleRequiredMPa) {
                endPEl.className = 'panel-stat-value ok';
            } else if (data.endPressureMPa >= hoseParams.minInletPressureMPa) {
                endPEl.className = 'panel-stat-value highlight';
            } else {
                endPEl.className = 'panel-stat-value warning';
            }
            
            // 可搬台数表示（根本1 + 中継N）
            document.getElementById('hoseInfoRelay').textContent = `${data.totalPumps}台 (中継${data.relayCount})`;
            document.getElementById('hoseInfoElev').textContent = (data.totalClimbM || 0).toFixed(1) + 'm↑';
            
            // 警告表示（末端圧が0.3未満の場合）
            const warning = document.getElementById('simWarning');
            if (data.endPressureMPa < hoseParams.nozzleRequiredMPa) {
                document.getElementById('simWarningText').textContent = 
                    `末端圧${data.endPressureMPa.toFixed(2)}MPa < 要求0.3MPa`;
                warning.classList.add('show');
            } else {
                warning.classList.remove('show');
            }
            
            // 区間詳細リスト更新（P1-P2形式）
            if (data.sections && data.relayIndices) {
                // ポンプ位置リスト作成: [0, relay1, relay2, ..., 終点]
                const pumpPositions = [0, ...data.relayIndices];
                const listEl = document.getElementById('segmentList');
                
                // 区間をポンプ間でグループ化
                let currentPumpNum = 1;
                let html = '';
                let segmentStart = 0;
                
                for (let pIdx = 0; pIdx < pumpPositions.length; pIdx++) {
                    const pumpStart = pumpPositions[pIdx];
                    const pumpEnd = pIdx < pumpPositions.length - 1 ? pumpPositions[pIdx + 1] : data.sections.length;
                    const nextPumpNum = pIdx < pumpPositions.length - 1 ? currentPumpNum + 1 : '筒先';
                    
                    // この区間（Pn → Pn+1 or 筒先）の集計
                    let segDist = 0, segHose = 0, segElev = 0;
                    let segEndPressure = 0;
                    
                    for (let i = segmentStart; i < pumpEnd && i < data.sections.length; i++) {
                        const s = data.sections[i];
                        segDist += s.lengthM;
                        segHose += s.nHose;
                        segElev += s.elevDiffM;
                        segEndPressure = s.remainingPressure;
                    }
                    
                    const colorClass = segEndPressure >= 0.4 ? 'green' : segEndPressure >= 0.2 ? 'yellow' : 'red';
                    const elevStr = segElev >= 0 ? `+${segElev.toFixed(0)}m` : `${segElev.toFixed(0)}m`;
                    
                    html += `<div class="segment-item">
                        <div class="segment-color ${colorClass}"></div>
                        <div class="segment-info">P${currentPumpNum}→${nextPumpNum}: ${segDist.toFixed(0)}m/${segHose}本, ${elevStr}</div>
                        <div class="segment-loss">${segEndPressure.toFixed(2)} MPa</div>
                    </div>`;
                    
                    currentPumpNum++;
                    segmentStart = pumpEnd;
                }
                
                listEl.innerHTML = html;
            }
        }

        // 区間色分けポリライン描画（残圧ベース）
        // 緑: 残圧 >= 0.4 (余裕あり)
        // 黄: 残圧 >= 0.2 (ギリギリOK)
        // 赤: 残圧 < 0.2 (中継必要)
        function renderColorizedSegments(lineId, pathLLH, sections) {
            // 既存の色分けセグメントを削除
            const prevSegs = hoseSimState.colorSegmentsByLine?.get(lineId) || [];
            prevSegs.forEach(e => viewer.entities.remove(e));
            
            if (!hoseSimState.colorSegmentsByLine) {
                hoseSimState.colorSegmentsByLine = new Map();
            }
            
            const segs = [];
            for (let i = 0; i < sections.length; i++) {
                const s = sections[i];
                const p1 = pathLLH[i], p2 = pathLLH[i + 1];
                
                // この区間終点での残圧（中継考慮済み）
                const remainingP = s.remainingPressure;
                
                let color;
                if (remainingP >= 0.4) {
                    color = Cesium.Color.fromCssColorString('#4ade80'); // 緑: 余裕あり
                } else if (remainingP >= 0.2) {
                    color = Cesium.Color.fromCssColorString('#fbbf24'); // 黄: ギリギリOK
                } else {
                    color = Cesium.Color.fromCssColorString('#ef4444'); // 赤: 中継必要
                }
                
                const seg = viewer.entities.add({
                    polyline: {
                        positions: [
                            Cesium.Cartesian3.fromDegrees(p1.lon, p1.lat, p1.height || 0),
                            Cesium.Cartesian3.fromDegrees(p2.lon, p2.lat, p2.height || 0)
                        ],
                        width: 6,
                        material: color,
                        clampToGround: true
                    }
                });
                segs.push(seg);
            }
            hoseSimState.colorSegmentsByLine.set(lineId, segs);
        }

        // シミュレーション実行（中継位置を考慮した新仕様）
        function runSimulationForLine(lineId, pathLLH) {
            // パラメータ更新（UIから）
            hoseParams.kFrictionMPaPer100m = parseFloat(document.getElementById('paramK').value) || 0.04;
            hoseParams.extraLossPerHoseMPa = parseFloat(document.getElementById('paramExtra').value) || 0.02;

            // 中継位置を計算
            const relayIndices = computeRelayPositions(pathLLH, hoseParams);
            
            // 中継位置を考慮した区間計算
            const sim = computeSectionsWithPressure(pathLLH, hoseParams, relayIndices);

            // マーカー描画
            renderStartEndMarkers(lineId, pathLLH);
            renderRelayMarkers(lineId, pathLLH, relayIndices);
            renderColorizedSegments(lineId, pathLLH, sim.sections);

            // 末端圧 = 最後の区間の残圧
            const endP = sim.sections.length > 0 
                ? sim.sections[sim.sections.length - 1].remainingPressure 
                : hoseParams.pumpOutputMPa;
            
            // 高低差（上りのみカウント）
            let totalClimb = 0;
            for (let i = 1; i < pathLLH.length; i++) {
                const dh = (pathLLH[i].height || 0) - (pathLLH[i-1].height || 0);
                if (dh > 0) totalClimb += dh;
            }

            // 可搬台数 = 根本(1) + 中継(relayIndices.length)
            const totalPumps = 1 + relayIndices.length;

            updateHoseInfoPanel({
                totalLengthM: sim.totalLengthM,
                totalHoses20m: sim.totalHoses20m,
                totalLossMPa: sim.totalLossMPa,
                endPressureMPa: endP,
                totalPumps: totalPumps,
                relayCount: relayIndices.length,
                totalClimbM: totalClimb,
                sections: sim.sections,
                relayIndices: relayIndices
            });
        }

        function onParamChange() {
            if (selectedHoseLine && selectedHoseLine.pathLLH) {
                runSimulationForLine(selectedHoseLine.id, selectedHoseLine.pathLLH);
            }
        }

        // 確定
        function confirmHoseLine() {
            if (hoseLinePoints.length < 2) { showToast('2点以上必要'); return; }
            
            const pathLLH = hoseLinePoints.map(p => ({ lon: p.lon, lat: p.lat, height: p.height }));
            const id = `hose-${++hoseLineIdCounter}`;
            
            let totalDist = 0, cumElev = 0;
            for (let i = 1; i < hoseLinePoints.length; i++) {
                totalDist += geodesicDistance(hoseLinePoints[i-1].lon, hoseLinePoints[i-1].lat, hoseLinePoints[i].lon, hoseLinePoints[i].lat);
                cumElev += Math.abs(hoseLinePoints[i].height - hoseLinePoints[i-1].height);
            }
            
            // ベースライン（選択用、太い半透明オレンジ）
            const lineEntity = viewer.entities.add({
                id: id,
                polyline: { positions: hoseLinePoints.map(p => p.cartesian), width: 12, material: Cesium.Color.ORANGE.withAlpha(0.3), clampToGround: true }
            });
            
            const hoseData = { id, entity: lineEntity, totalDist, count: Math.ceil(totalDist / 20), cumElev, pathLLH };
            hoseLineEntities.push(hoseData);

            // マーカー削除
            hoseLineMarkers.forEach(e => viewer.entities.remove(e));
            hoseLineSegments.forEach(e => viewer.entities.remove(e));
            hoseLinePoints = []; hoseLineMarkers = []; hoseLineSegments = [];
            updateHoseDisplay();
            document.getElementById('hoseHint').textContent = '確定！';

            // シミュレーション実行＆パネル表示
            selectedHoseLine = hoseData;
            runSimulationForLine(id, pathLLH);
            closeAllPanels();
            document.getElementById('hoseInfoPanel').classList.add('active');
            
            showToast('ホース経路を確定しました');
        }

        function selectHoseLine(id) {
            const h = hoseLineEntities.find(x => x.id === id);
            if (!h) return;
            selectedHoseLine = h;
            closeAllPanels();
            
            if (h.pathLLH) {
                runSimulationForLine(id, h.pathLLH);
            } else {
                document.getElementById('hoseInfoDist').textContent = formatDistance(h.totalDist);
                document.getElementById('hoseInfoCount').textContent = h.count + '本';
                document.getElementById('hoseInfoElev').textContent = h.cumElev.toFixed(1) + 'm';
            }
            document.getElementById('hoseInfoPanel').classList.add('active');
        }

        function deleteSelectedHose() {
            if (!selectedHoseLine) { showToast('ホース経路が選択されていません'); return; }
            const lineId = selectedHoseLine.id;
            
            // 関連マーカー削除
            const startEnd = hoseSimState.startEndEntitiesByLine.get(lineId);
            if (startEnd) {
                if (startEnd.start) viewer.entities.remove(startEnd.start);
                if (startEnd.end) viewer.entities.remove(startEnd.end);
                hoseSimState.startEndEntitiesByLine.delete(lineId);
            }
            const cands = hoseSimState.relayCandidateEntitiesByLine.get(lineId) || [];
            cands.forEach(e => viewer.entities.remove(e));
            hoseSimState.relayCandidateEntitiesByLine.delete(lineId);
            
            const confs = hoseSimState.relayConfirmedEntitiesByLine.get(lineId) || [];
            confs.forEach(e => viewer.entities.remove(e));
            hoseSimState.relayConfirmedEntitiesByLine.delete(lineId);
            hoseSimState.relayConfirmedIdxByLine.delete(lineId);
            
            // 色分けセグメント削除
            if (hoseSimState.colorSegmentsByLine) {
                const colorSegs = hoseSimState.colorSegmentsByLine.get(lineId) || [];
                colorSegs.forEach(e => viewer.entities.remove(e));
                hoseSimState.colorSegmentsByLine.delete(lineId);
            }
            
            // ライン本体削除
            viewer.entities.remove(selectedHoseLine.entity);
            hoseLineEntities = hoseLineEntities.filter(h => h.id !== lineId);
            selectedHoseLine = null;
            closePanel('hoseInfo');
            showToast('ホース経路を削除');
        }

        function closeHosePanel() { document.getElementById('hosePanel').classList.remove('active'); resetHoseLine(); clearTool(); }

        // ========== MEASURE ==========
        let measurePoints = [], measureEntities = [];
        function addMeasurePoint(lon, lat, height, cartesian) {
            measurePoints.push({ lon, lat, height, cartesian });
            measureEntities.push(viewer.entities.add({ position: cartesian, point: { pixelSize: 7, color: Cesium.Color.CYAN, outlineColor: Cesium.Color.WHITE, outlineWidth: 1, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND } }));
            if (measurePoints.length === 2) {
                const p1 = measurePoints[0], p2 = measurePoints[1];
                measureEntities.push(viewer.entities.add({ polyline: { positions: [p1.cartesian, p2.cartesian], width: 2, material: Cesium.Color.CYAN.withAlpha(0.8), clampToGround: true } }));
                document.getElementById('measureDistance').textContent = formatDistance(geodesicDistance(p1.lon, p1.lat, p2.lon, p2.lat));
                document.getElementById('measureElevation').textContent = ((p2.height - p1.height) >= 0 ? '+' : '') + (p2.height - p1.height).toFixed(1) + 'm';
                document.getElementById('measureHint').style.display = 'none';
            }
        }
        function resetMeasure() { measurePoints = []; measureEntities.forEach(e => viewer.entities.remove(e)); measureEntities = []; document.getElementById('measureDistance').textContent = '-'; document.getElementById('measureElevation').textContent = '-'; document.getElementById('measureHint').style.display = 'block'; }
        function closeMeasurePanel() { document.getElementById('measurePanel').classList.remove('active'); resetMeasure(); clearTool(); }

        // ========== Search ==========
        async function doSearch() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;
            showLoading(true);
            try {
                const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&countrycodes=jp`);
                const data = await res.json();
                if (!data.length) { showToast('見つかりませんでした'); showLoading(false); return; }
                const resultsDiv = document.getElementById('searchResults');
                resultsDiv.innerHTML = data.map(r => `<div class="search-result-item" onclick="goToSearchResult(${r.lat},${r.lon})"><div class="search-result-name">${r.display_name.split(',')[0]}</div><div class="search-result-address">${r.display_name}</div></div>`).join('');
                resultsDiv.classList.add('show');
            } catch(e) { showToast('検索エラー'); }
            showLoading(false);
        }
        function goToSearchResult(lat, lon) { document.getElementById('searchResults').classList.remove('show'); viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(lon, lat, 1500), duration: 1.5 }); }
        document.addEventListener('click', e => { if (!e.target.closest('.search-box') && !e.target.closest('.search-results')) document.getElementById('searchResults').classList.remove('show'); });

        // ========== Geolocation ==========
        let myLat = null, myLon = null, myLocationEntity = null;
        function flyToMyLocation() { if (myLat && myLon) viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(myLon, myLat, 800), duration: 1.5 }); }
        function updateMyLocationMarker() { if (!myLat || !myLon) return; if (myLocationEntity) viewer.entities.remove(myLocationEntity); myLocationEntity = viewer.entities.add({ position: Cesium.Cartesian3.fromDegrees(myLon, myLat), point: { pixelSize: 12, color: Cesium.Color.fromCssColorString('#4ade80'), outlineColor: Cesium.Color.WHITE, outlineWidth: 2, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND } }); }
        if ('geolocation' in navigator) { navigator.geolocation.watchPosition(pos => { myLat = pos.coords.latitude; myLon = pos.coords.longitude; document.getElementById('myCoords').textContent = `${myLat.toFixed(4)}°, ${myLon.toFixed(4)}°`; updateMyLocationMarker(); }, () => { document.getElementById('myCoords').textContent = '取得失敗'; }, { enableHighAccuracy: true, maximumAge: 5000, timeout: 15000 }); }

        // Coord display
        const coordHandler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        coordHandler.setInputAction(movement => { const ray = viewer.camera.getPickRay(movement.endPosition); const cartesian = viewer.scene.globe.pick(ray, viewer.scene); if (cartesian) { const carto = Cesium.Cartographic.fromCartesian(cartesian); document.getElementById('coordDisplay').textContent = `${Cesium.Math.toDegrees(carto.latitude).toFixed(5)}°, ${Cesium.Math.toDegrees(carto.longitude).toFixed(5)}°`; } }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

        // ========== Tool system ==========
        let currentTool = null;
        function clearTool() { document.querySelectorAll('.tool-item').forEach(t => t.classList.remove('active')); document.getElementById('modeIndicator').classList.remove('show', 'water-mode', 'hose-mode', 'measure-mode'); currentTool = null; }
        function setTool(tool) {
            clearTool();
            document.getElementById('hosePanel').classList.remove('active');
            document.getElementById('measurePanel').classList.remove('active');
            document.getElementById('toolMenu').classList.remove('show');
            closeAllPanels();
            if (currentTool === tool) return;
            currentTool = tool;
            const ind = document.getElementById('modeIndicator'), icon = document.getElementById('modeIcon'), text = document.getElementById('modeText');
            if (tool === 'fire') { document.getElementById('toolFire').classList.add('active'); icon.textContent = 'local_fire_department'; text.textContent = '火点追加'; ind.classList.add('show'); }
            else if (tool === 'water') { document.getElementById('toolWater').classList.add('active'); icon.textContent = 'water_drop'; text.textContent = '水利追加'; ind.classList.add('show', 'water-mode'); }
            else if (tool === 'hose') { document.getElementById('toolHose').classList.add('active'); icon.textContent = 'route'; text.textContent = 'ホース延長(林野)'; ind.classList.add('show', 'hose-mode'); document.getElementById('hosePanel').classList.add('active'); resetHoseLine(); }
            else if (tool === 'measure') { document.getElementById('toolMeasure').classList.add('active'); icon.textContent = 'straighten'; text.textContent = '2点計測'; ind.classList.add('show', 'measure-mode'); document.getElementById('measurePanel').classList.add('active'); resetMeasure(); }
        }

        // Panel helpers
        function closeAllPanels() { ['firePanel', 'waterPanel', 'hoseInfoPanel'].forEach(id => document.getElementById(id).classList.remove('active')); selectedFirePoint = null; selectedWater = null; }
        function closePanel(type) { document.getElementById(type + 'Panel').classList.remove('active'); if (type === 'fire') selectedFirePoint = null; if (type === 'water') selectedWater = null; if (type === 'hoseInfo') selectedHoseLine = null; }

        // ========== Click handler ==========
        const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        handler.setInputAction(async function(click) {
            const picked = viewer.scene.pick(click.position);
            
            if (picked && picked.id && picked.id.id) {
                const pickedId = picked.id.id;
                
                if (pickedId.startsWith('fire-')) { selectFirePoint(pickedId); return; }
                if (pickedId.startsWith('water-')) { selectWater(pickedId); return; }
                if (pickedId.startsWith('hose-')) { selectHoseLine(pickedId); return; }
            }
            
            const ray = viewer.camera.getPickRay(click.position);
            const cartesian = viewer.scene.globe.pick(ray, viewer.scene);
            if (!cartesian) return;
            const carto = Cesium.Cartographic.fromCartesian(cartesian);
            const lon = Cesium.Math.toDegrees(carto.longitude), lat = Cesium.Math.toDegrees(carto.latitude);
            let height = 0;
            try { const u = await Cesium.sampleTerrainMostDetailed(viewer.terrainProvider, [Cesium.Cartographic.fromDegrees(lon, lat)]); height = u[0].height || 0; } catch(e) { height = carto.height || 0; }
            
            if (currentTool === 'fire') { const id = addFirePoint(lon, lat, height); selectFirePoint(id); }
            else if (currentTool === 'water') { const id = addWaterSource('hydrant', `消火栓#${waterIdCounter + 1}`, lon, lat); selectWater(id); }
            else if (currentTool === 'hose') { addHosePoint(lon, lat, height, cartesian); }
            else if (currentTool === 'measure') { if (measurePoints.length >= 2) resetMeasure(); addMeasurePoint(lon, lat, height, cartesian); }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        // ========== Utilities ==========
        function geodesicDistance(lon1, lat1, lon2, lat2) { const geodesic = new Cesium.EllipsoidGeodesic(Cesium.Cartographic.fromDegrees(lon1, lat1), Cesium.Cartographic.fromDegrees(lon2, lat2)); return geodesic.surfaceDistance; }
        function formatDistance(m) { return m >= 1000 ? (m/1000).toFixed(2) + 'km' : m.toFixed(0) + 'm'; }
        function showLoading(show) { document.getElementById('loading').classList.toggle('show', show); }
        function showToast(msg) { const t = document.getElementById('toast'); t.textContent = msg; t.classList.remove('show'); void t.offsetWidth; t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 2500); }
        function setViewMode(mode) { document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active')); event.target.closest('.view-btn').classList.add('active'); viewer.scene.mode = mode === '2d' ? Cesium.SceneMode.SCENE2D : Cesium.SceneMode.SCENE3D; }
        function shareView() { const p = viewer.camera.positionCartographic; navigator.clipboard.writeText(`${location.origin}${location.pathname}?lat=${Cesium.Math.toDegrees(p.latitude).toFixed(6)}&lon=${Cesium.Math.toDegrees(p.longitude).toFixed(6)}&h=${p.height.toFixed(0)}`).then(() => showToast('URLをコピー')); }
        const params = new URLSearchParams(location.search); if (params.has('lat') && params.has('lon')) { viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(parseFloat(params.get('lon')), parseFloat(params.get('lat')), parseFloat(params.get('h')) || 3000), duration: 2 }); }
    </script>
</body>
</html>
